/* ====================================================================
 * Author           : tianyh(mknight)
 * Email            : 824338670@qq.com
 * Last modified    : 2022-07-25 11:33
 * Filename         : funchelp.go
 * Description      : 生成config代码文件
 * ====================================================================*/
package csvtools

import (
	"fmt"
	"os"
	"roomcell/pkg/funchelp"
	"strings"

	"github.com/360EntSecGroup-Skylar/excelize"
	"github.com/sirupsen/logrus"
)

const (
	ExcelFieldTypeInt         = "int"
	ExcelFieldTypeArrayInt    = "array_int"
	ExcelFieldTypeString      = "string"
	ExcelFieldTypeArrayString = "array_string"
)

// 字段信息
type FieldInfo struct {
	name      string
	fieldType string
	//
	nameAaBb      string
	fieldTypeToGo string
}

// 读取结构描述
func ReadFieldInfo(excelFile string) []*FieldInfo {
	fieldList := make([]*FieldInfo, 0)

	f, err := excelize.OpenFile(excelFile)
	if err != nil {
		logrus.Errorf("open file[%s]error:%s", excelFile, err.Error())
		return fieldList
	}
	rows := f.GetRows("Sheet1") // 默认读取第一个表单
	if len(rows) < 4 {
		return fieldList
	}
	resultRows := make([][]string, len(rows))
	for r, oneRow := range rows {
		newRow := make([]string, 0)
		// head 部分检测
		for c, oneColumn := range oneRow {
			if len(rows[0][c]) == 0 || len(rows[1][c]) == 0 || len(rows[2][c]) == 0 || len(rows[3][c]) == 0 {
				continue
			}
			newRow = append(newRow, oneColumn)
		}
		resultRows[r] = newRow
		if r >= 4 {
			break
		}
	}
	headMeta := resultRows
	for i, row := range headMeta {
		// 字段名字
		if i == 2 {
			for c, columnStr := range row {
				oneField := &FieldInfo{
					name:      columnStr,
					fieldType: headMeta[3][c],
				}
				oneField.nameAaBb = funchelp.StringToAaBb(columnStr)
				// go 类型映射
				switch oneField.fieldType {
				case ExcelFieldTypeInt:
					{
						oneField.fieldTypeToGo = "int32"
						break
					}
				case ExcelFieldTypeArrayInt:
					{
						oneField.fieldTypeToGo = "[]int32"
						break
					}
				case ExcelFieldTypeString:
					{
						oneField.fieldTypeToGo = "string"
						break
					}
				case ExcelFieldTypeArrayString:
					{
						oneField.fieldTypeToGo = "[]string"
						break
					}
				}
				fieldList = append(fieldList, oneField)
			}
			break
		}
	}
	return fieldList
}

// 生成csv结构文件
func GenerageCSVDefCode(goModuleName string, pkgPath string, excelFile string) {
	fieldList := ReadFieldInfo(excelFile)
	if len(fieldList) < 1 {
		return
	}
	tableName := fetchFileNameWithoutExtension(excelFile)
	tableNameAaBb := funchelp.StringToAaBb(tableName)
	codeFilePath := fmt.Sprintf("%s/configdata/csvdef/excel_%s.go", pkgPath, tableName)
	var fileObj *os.File
	var fileErr error
	if funchelp.CheckFileIsExist(codeFilePath) {
		fileObj, fileErr = os.OpenFile(codeFilePath, os.O_RDWR, 0666) //打开文件
		if fileErr != nil {
			return
		}
	} else {
		fileObj, fileErr = os.Create(codeFilePath) //创建文件
		if fileErr != nil {
			return
		}
	}
	defer fileObj.Close()
	fileObj.Truncate(0)
	fileObj.WriteString("// this file generated by tools,don't edit it!!!\n")
	codeTemplate :=
		`package csvdef
import (
	"%s/pkg/configdata/csvparse"
	"strings"

	"github.com/sirupsen/logrus"
)
`
	fileObj.WriteString(fmt.Sprintf(codeTemplate, goModuleName))
	// part1:字段常量
	fileObj.WriteString("const (\n")
	for i, fieldInfo := range fieldList {
		if i == 0 {
			fileObj.WriteString(fmt.Sprintf("\t%sColumn%s = iota\n", tableNameAaBb, fieldInfo.nameAaBb))
		} else {
			fileObj.WriteString(fmt.Sprintf("\t%sColumn%s\n", tableNameAaBb, fieldInfo.nameAaBb))
		}
	}
	fileObj.WriteString(")\n")
	// part2:struct结构
	// 最长的字段
	maxFieldLen := 0
	for _, f := range fieldList {
		if len(f.nameAaBb) > maxFieldLen {
			maxFieldLen = len(f.nameAaBb)
		}
	}
	fileObj.WriteString(fmt.Sprintf("type %s struct {\n", tableNameAaBb))
	codeTemplate = "\t%s\t%s\n"
	for _, fieldInfo := range fieldList {
		structName := fieldInfo.nameAaBb
		if len(fieldInfo.nameAaBb) < maxFieldLen {
			for j := 0; j < maxFieldLen-len(fieldInfo.nameAaBb); j++ {
				structName = structName + " "
			}
		}
		fileObj.WriteString(fmt.Sprintf(codeTemplate, structName, fieldInfo.fieldTypeToGo))
	}

	fileObj.WriteString(fmt.Sprintf("}\n"))
	// part3: csv module
	codeTemplate =
		`type %sCfgModule struct {
	cfgMap  map[int32]*%s
	cfgList []*%s
}
`
	fileObj.WriteString(fmt.Sprintf(codeTemplate, tableNameAaBb, tableNameAaBb, tableNameAaBb))
	codeTemplate = `
func New%sCfgModule() *%sCfgModule {
	return &%sCfgModule{
		cfgMap: make(map[int32]*%s),
	}
}
`
	fileObj.WriteString(fmt.Sprintf(codeTemplate, tableNameAaBb, tableNameAaBb, tableNameAaBb, tableNameAaBb))
	// load
	fileObj.WriteString(fmt.Sprintf("\nfunc (cfgMod *%sCfgModule) Load(lineList []string) {\n", tableNameAaBb))
	fileObj.WriteString(fmt.Sprintf("\tlogrus.Info(\"%sCfgModule begin load\")\n", tableNameAaBb))
	fileObj.WriteString(fmt.Sprintf("\tcfgMod.cfgList=make([]*%s, len(lineList))\n", tableNameAaBb))
	fileObj.WriteString("\tfor i, lstr := range lineList {\n")
	fileObj.WriteString(fmt.Sprintf("\t\tcolumnList := strings.Split(lstr, \",\")\n"))
	fileObj.WriteString(fmt.Sprintf("\t\toneData := &%s{}\n", tableNameAaBb))
	// 每个字段
	for _, fieldInfo := range fieldList {
		switch fieldInfo.fieldType {
		case ExcelFieldTypeInt:
			{
				fileObj.WriteString(fmt.Sprintf("\t\toneData.%s = csvparse.ParseColumnInt(columnList[%sColumn%s])\n", fieldInfo.nameAaBb, tableNameAaBb, fieldInfo.nameAaBb))
				break
			}
		case ExcelFieldTypeArrayInt:
			{
				fileObj.WriteString(fmt.Sprintf("\t\toneData.%s = csvparse.ParseColumnArrayInt(columnList[%sColumn%s])\n", fieldInfo.nameAaBb, tableNameAaBb, fieldInfo.nameAaBb))
				break
			}
		case ExcelFieldTypeString:
			{
				fileObj.WriteString(fmt.Sprintf("\t\toneData.%s = csvparse.ParseColumnString(columnList[%sColumn%s])\n", fieldInfo.nameAaBb, tableNameAaBb, fieldInfo.nameAaBb))
				break
			}
		case ExcelFieldTypeArrayString:
			{
				fileObj.WriteString(fmt.Sprintf("\t\toneData.%s = csvparse.ParseColumnArrayString(columnList[%sColumn%s])\n", fieldInfo.nameAaBb, tableNameAaBb, fieldInfo.nameAaBb))
				break
			}
		}
	}
	fileObj.WriteString(fmt.Sprintf("\t\tcfgMod.cfgMap[oneData.ID] = oneData\n"))
	fileObj.WriteString(fmt.Sprintf("\t\tcfgMod.cfgList[i] = oneData\n"))
	fileObj.WriteString(fmt.Sprintf("\t}\n"))

	// endTag := `
	// logrus.Infof("%sCfgModule load finish!!!")\n
	// `
	// fileObj.WriteString(fmt.Sprintf(endTag, tableNameAaBb))
	fileObj.WriteString(fmt.Sprintf("\tlogrus.Infof(\"%sCfgModule load finish!", tableNameAaBb) + "dataNum:%d\"" + fmt.Sprintf(",len(cfgMod.cfgList))\n"))
	fileObj.WriteString(fmt.Sprintf("}\n"))
	// module get data
	codeTemplate = `
func (cfgMod *%sCfgModule) GetData(id int32) *%s {
	if cfg, ok := cfgMod.cfgMap[id]; ok {
		return cfg
	}
	return nil
}

func (cfgMod *%sCfgModule) GetDataList() []*%s {
	return cfgMod.cfgList
}
`
	fileObj.WriteString(fmt.Sprintf(codeTemplate, tableNameAaBb, tableNameAaBb, tableNameAaBb, tableNameAaBb))
	fileObj.Sync()
}

// 添加到管理器
func CSVModuleJoinToConfigMgr(excelFile string, pkgPath string) {
	tableName := fetchFileNameWithoutExtension(excelFile)
	codeFilePath := fmt.Sprintf("%s/configdata/csv_module_manager.go", pkgPath)
	if !funchelp.CheckFileIsExist(codeFilePath) {
		logrus.Errorf("not find file:%s", codeFilePath)
		return
	}
	lineList := funchelp.ReadFileForLineStr(codeFilePath)
	var fileObj *os.File
	var fileErr error
	fileObj, fileErr = os.OpenFile(codeFilePath, os.O_RDWR, 0666) //打开文件
	if fileErr != nil {
		return
	}
	defer fileObj.Close()
	fileObj.Truncate(0)
	tableNameaaBb := funchelp.StringToaaBb(tableName)
	tableNameAaBb := funchelp.StringToAaBb(tableName)
	moduleMemberName := fmt.Sprintf("%sModule", tableNameaaBb)
	memberType := fmt.Sprintf("*csvdef.%sCfgModule", tableNameAaBb)
	moduleMemberDeclare := fmt.Sprintf("%sModule *csvdef.%sCfgModule", funchelp.StringToaaBb(tableName), funchelp.StringToAaBb(tableName))
	loadCode := fmt.Sprintf("mgr.%s.Load", moduleMemberName)
	tagValue := 0 // 原样输出
	for _, lineStr := range lineList {
		if tagValue == 1 && strings.Index(lineStr, moduleMemberName) != -1 && strings.Index(lineStr, memberType) != -1 {
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else if tagValue == 1 && strings.Index(lineStr, "csvmodule tag1 end") != -1 {
			// 追加
			fileObj.WriteString("\t" + moduleMemberDeclare + "\n")
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else if tagValue == 2 && strings.Index(lineStr, moduleMemberName+":") != -1 {
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else if tagValue == 2 && strings.Index(lineStr, "csvmodule tag2 end") != -1 {
			// 追加初始化
			fileObj.WriteString(fmt.Sprintf("\t\t%s: csvdef.New%sCfgModule(),\n", moduleMemberName, tableNameAaBb))
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else if tagValue == 3 && strings.Index(lineStr, loadCode) != -1 {
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else if tagValue == 3 && strings.Index(lineStr, "csvmodule tag3 end") != -1 {
			// 追加load
			codeLoadGen := "\t" + loadCode + "(csvparse.ParseCsvFileLine(fmt.Sprintf(\"%s/%s\",mgr.filePath, \""
			codeLoadGen = codeLoadGen + tableName + ".csv\")))\n"
			fileObj.WriteString(codeLoadGen)
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else {
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			if strings.Index(lineStr, "csvmodule tag1 begin") != -1 {
				tagValue = 1
			} else if strings.Index(lineStr, "csvmodule tag2 begin") != -1 {
				tagValue = 2
			} else if strings.Index(lineStr, "csvmodule tag3 begin") != -1 {
				tagValue = 3
			}
		}
	}
}

// 生成导出接口
func ExportConfigMgrInterface(excelFile string, pkgPath string) {
	tableName := fetchFileNameWithoutExtension(excelFile)
	codeFilePath := fmt.Sprintf("%s/configdata/csvconfig_export.go", pkgPath)
	if !funchelp.CheckFileIsExist(codeFilePath) {
		logrus.Errorf("not find file:%s", codeFilePath)
		return
	}
	lineList := funchelp.ReadFileForLineStr(codeFilePath)
	var fileObj *os.File
	var fileErr error
	fileObj, fileErr = os.OpenFile(codeFilePath, os.O_RDWR, 0666) //打开文件
	if fileErr != nil {
		return
	}
	defer fileObj.Close()
	fileObj.Truncate(0)
	tableNameaaBb := funchelp.StringToaaBb(tableName)
	tableNameAaBb := funchelp.StringToAaBb(tableName)
	visitCode := fmt.Sprintf("return cfg.csvModules.%s", tableNameaaBb)
	tagValue := 0 // 原样输出
	for _, lineStr := range lineList {
		if tagValue == 1 && strings.Index(lineStr, visitCode) != -1 {
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else if tagValue == 1 && strings.Index(lineStr, "config export interface end") != -1 {
			// 追加
			codeTemplate := `func (cfg *ConfigData) Get%sCfg(id int32) *csvdef.%s {
	return cfg.csvModules.%sModule.GetData(id)
}
func (cfg *ConfigData) Get%sCfgList() []*csvdef.%s {
	return cfg.csvModules.%sModule.GetDataList()
}

`
			fileObj.WriteString(fmt.Sprintf(codeTemplate, tableNameAaBb, tableNameAaBb, tableNameaaBb, tableNameAaBb, tableNameAaBb, tableNameaaBb))
			fileObj.WriteString(lineStr + "\n")
			tagValue = 0
		} else {
			// 原样输出
			fileObj.WriteString(lineStr + "\n")
			if strings.Index(lineStr, "// config export interface begin") != -1 {
				tagValue = 1
			}
		}
	}
	fileObj.Sync()
}
